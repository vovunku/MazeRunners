# MazeRunners
## Кухаренко Владимир, группа Б05-925
## UPD2
## Как этим чудом пользоваться?
### Перед началом:
Нужно склонировать себе проект. Далее запустить main.py(при запуске он подхватит путь до maps, в котором будут лежать карты. Далее мы попадаем в меню. Пока что все команды нужно писать так, как предлагается(в большистве случаев - это цифры + доп инфа, в игре - это словесные команды). Позже я добавлю возможность писать команды в различных форматах(для этого надо будет подтянуть прокси). Чтобы ориентироваться в менюшке - нужны только цифры - 1, 2, 3.
### Режим игры
Здесь вам будет предложено выбрать карту из имеющихся(для этого пишем ее номер в списке). После этого нужно будет последовательно ввести информацию об игроках. Для начала - цифрой - количество игроков, а затем - тройка координат на каждого. Пример:  
3  
1 1 1  
1 2 2  
1 3 3  

После этого начнется игра, и будет выведен список возможных команд. Здесь команды пишутся в lowercase, а направления в uppercase.
###### Важно! ход надо заканчивать при помощи "end"
Пример:
help  
move DOWN  
shoot RIGHT  
end  

Когда игра заканчивается - все выбрасывается в меню
### Режим изменения карт
будет две опции - проверить карту на корректность и добавить карту в хранилище(в обоих случаях требуется путь до карты)
Пример проверки и добавления:  
1 /home/vovun/PycharmProjects/MazeRunners/maps/2.txt  
2 /home/vovun/PycharmProjects/MazeRunners/maps/2.txt  

### Описание карт
Пример:  
1  
3 3  
.|S E  
. . _  
S T L  
. . .  
A R .  
E Exit(UP)  
S Stun(2)  
A Armory()  
R RubberRoom(RIGHT)  
L RubberRoom(LEFT)  
T Teleport(1 1 3)  

описание почти как в задании. Разница в том, что мы сразу пишем количество карт - n. А далее в n строках описываем карты по отдельности. В описание клетки передаем необходимые параметры:
Exit(<DESTINATION>)  
RubberRoom(<DESTINATION>)  
Teleport(<lay> <x> <y>)  
Stun(<num>)  

### 1. Ввод, вывод - receiver display 
Реализация Bridge, с целью возможности дальнейшего расширения функционала. Думаю сделать так, чтобы эти модули передавали данные в каком-то определенном формате, но непонятно, насколько это правильно. Возможно имеет смысл сделать отдельный класс для данных, чтобы модули могли работать на удобных языках, но непонятно как это делать.
### 2. Фасад меню - menu_facade
Это фасад фасадов. Он будет предоставлять доступ к другим фасадам(и правильно инициализировать их соответственно) по желанию пользователя.
### 3. Игровой клиент - game_facade
Реализация Facade, для предоставления ограниченной функциональности и реализации взаимодействия между пользователями их виртуальными игроками и игрой в целом. 
### 4. Игровое поле - Board
Реализация хранения ячеек и взаимодействия окружающей среды с совокупностью ячеек. 
### 5. Игрок - Player
Реализация выполнения последовательности комманд (например, ход каждого игрока делится на три части: взаимодествие с окружением, ход, завершение хода. При этом в любой момент игрок может захотеть увидеть подсказку по управлению, заглянуть в рюкзак и тд) с помощь Chain of Responsibility. Реализовано через Фабричный метод, чтобы игроки могли быть кастомными.
### 6. Клетки - Cell
Реализация основных объектов в игре. Реализация Фабричного метода, т.к. базовая функциональность у всех клеток одинакова (посмотреть, взаимодействовать, сдвинуться, плюс содержание). Для передачи информации от клеток объектам используем Command(таким образом мы можем логировать действия игрока и разделить реализации клеток и игроков)
### 7. Команда - Command
С помощью нее будет работать изменение игрока, в зависимости от его действий. Пока что видится, что для каждого вида клетки нужна своя команда, но это не очень хорошо. Исправить не получилось, команд целая уйма - это большая проблема.
### 8. Фасад добавления карт - map_editor, который за собой тянет map_manager
Сейчас оно умеет доставать карты из хранилища, и добавлять их туда же. При добавлении делает небольшую проверку на корректность бфсом, и, если что, выводит, из какой клетки до выхода дойти не удалось
### 9. Хранилище карт - пресловутый map_manager
Отдельные файл(ы) и класс, который работает с этим хранилищем - проверяет, добавляет и удаляет карты.
### 10. Проверка валидности карты.
Пока что кажется, что нужно только BFS. Но нужна еще проверка корректности формата. А вот тут уже непонятно, как релизовывать 
### 11. Прокси
Будет реализовано в виде декоратора. Основная его цель - проверка того, что данные полученные от модуля 1 - корректные. Можно будет задавать в каких ячейках полученного листа какие слова должны лежать. Возможно еще будет логическая проверка(по хорошему надо)
## Дополнения
### 1. Добавление доп. логики клеток
Реализация клеток, которые отправляют игрока на другое поле. Реализация выхода с помощью ключа
### 2. Генерация случайных карт
